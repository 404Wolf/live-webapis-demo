# Web APIs

What is a WebAPI?

https://developer.mozilla.org/en-US/docs/Web/API

![Web Vibration API](https://static.404wolf.com/web-vibration.png)

The syscalls of the internet!

# Fetching Weather Data

```javascript
fetch('https://wttr.in/Cleveland?format=j1')
  .then(response => response.json())
  .then(data => {
    const current = data.current_condition[0];
    console.log(`Temperature: ${current.temp_C}°C`);
    console.log(`Weather: ${current.weatherDesc[0].value}`);
  })
  .catch(error => console.error('Error:', error));
```

# Recall HTTP

```http
GET /api/users/123 HTTP/1.1\r\n
Host: example.com\r\n
Accept: application/json\r\n
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\r\n
User-Agent: Mozilla/5.0\r\n
\r\n
HTTP/1.1 200 OK\r\n
Content-Type: application/json\r\n
Content-Length: 85\r\n
\r\n
{
  "id": 123,
  "name": "John Doe",
  "email": "john@example.com"
}
```

# SSE

Server sent events!!

https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events

## Fetch vs SSE Comparison

| Feature | Fetch API | Server-Sent Events (SSE) |
|---------|-----------|--------------------------|
| **Direction** | Request-Response | Server → Client only |
| **Connection** | One-time | Persistent |
| **Real-time** | No | Yes |
| **Data Format** | Any (JSON, text, etc.) | Text-based events |
| **Overhead** | New connection per request | Single connection |
| **Error Handling** | Promise-based | Event-based |
| **Use Case** | API calls, file uploads | Live updates, notifications |

# WebSockets

RFC nitty gritty!

> # Extension Negotiation (RFC 6455 §9)

> WebSocket extensions allow endpoints to modify how frames are interpreted  
> (e.g., compression, multiplexing) without breaking protocol compatibility.
> ---

> During the **opening handshake**, the client proposes extensions via the  
> `Sec-WebSocket-Extensions` header:

```
GET /chat HTTP/1.1
Host: example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Version: 13
Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits
```

# Frames

```
0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-------+-+-------------+-------------------------------+
    |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
    |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
    |N|V|V|V|       |S|             |   (if payload len==126/127)   |
    | |1|2|3|       |K|             |                               |
    +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
    |     Extended payload length continued, if payload len == 127  |
    + - - - - - - - - - - - - - - - +-------------------------------+
    |                               |Masking-key, if MASK set to 1  |
    +-------------------------------+-------------------------------+
    | Masking-key (continued)       |          Payload Data         |
    +-------------------------------- - - - - - - - - - - - - - - - +
    :                     Payload Data continued ...                :
    + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    |                     Payload Data continued ...                |
    +---------------------------------------------------------------+
```

## RSV1

Extension: permessage-deflate (RFC 7692)

Use RSV1 to say "Yes i am compressed!!"

https://datatracker.ietf.org/doc/html/rfc7692

This document specifies a framework for adding compression
functionality to the WebSocket Protocol [RFC6455].  The framework
specifies how to define WebSocket Per-Message Compression Extensions
(PMCEs) for a compression algorithm based on the extension concept of
the WebSocket Protocol specified in Section 9 of [RFC6455].  A
WebSocket client and a peer WebSocket server negotiate the use of a
PMCE and determine the parameters required to configure the
compression algorithm during the WebSocket opening handshake.  The
client and server can then exchange data messages whose frames
contain compressed data in the payload data portion.

# Big Frames

Let’s say you want to send a 10 MB binary file.
You could theoretically make one huge frame -- but that’s not ideal for:

- Memory allocation (you’d need a full buffer before sending)
- Streaming or progressive transmission
- Interleaving pings/pongs between fragments
- So instead, you can split the message:

## Frames continued

RSV1, RSV2, RSV3:  1 bit each

MUST be 0 unless an extension is negotiated that defines meanings
for non-zero values.  If a nonzero value is received and none of
the negotiated extensions defines the meaning of such a nonzero
value, the receiving endpoint MUST _Fail the WebSocket
Connection_.

| Frame | Opcode | FIN | Meaning | Identification |
|-------|--------|-----|---------|----------------|
| #1 | 0x2 (binary) | 0 | First fragment | Opcode != 0x0, FIN = 0 |
| #2 | 0x0 (continuation) | 0 | Middle fragment | Opcode = 0x0, FIN = 0 |
| #3 | 0x0 (continuation) | 1 | Final fragment | Opcode = 0x0, FIN = 1 |


# Opcodes

```
Opcode:  4 bits

    Defines the interpretation of the "Payload data".  If an unknown
    opcode is received, the receiving endpoint MUST _Fail the
    WebSocket Connection_.  The following values are defined.

    *  %x0 denotes a continuation frame
    *  %x1 denotes a text frame
    *  %x2 denotes a binary frame
    *  %x3-7 are reserved for further non-control frames
    *  %x8 denotes a connection close
    *  %x9 denotes a ping
    *  %xA denotes a pong
    *  %xB-F are reserved for further control frames
```

## What are pings??

A ping is a heartbeat. What is a heartbeat?

It's just "I'm still here, pls do not close my connection <3"